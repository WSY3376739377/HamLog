# -*- coding: utf-8 -*-
import datetime

def _format_field(tag, value):
    """将单个字段格式化为 ADIF 标签"""
    if not value:
        return ""
    value_str = str(value)
    return f"<{tag}:{len(value_str)}>{value_str} "

def export_to_adif(records, filepath):
    """
    将QSO记录列表导出为ADIF文件。
    records: 从数据库查询到的记录元组列表。
    filepath: 导出的文件路径。
    """
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write("Generated by HamLog\n")
            f.write("<EOH>\n\n")

            for rec in records:
                # 数据库字段: id, call, mode, freq, power, datetime, qth_prov, qth_city, rst_sent, rst_recv, device, content
                adif_record = ""
                adif_record += _format_field("CALL", rec[1])
                adif_record += _format_field("MODE", rec[2])
                
                # 格式化日期和时间
                try:
                    dt_obj = datetime.datetime.strptime(rec[5], '%Y-%m-%d %H:%M')
                    adif_record += _format_field("QSO_DATE", dt_obj.strftime('%Y%m%d'))
                    adif_record += _format_field("TIME_ON", dt_obj.strftime('%H%M%S'))
                except (ValueError, TypeError):
                    pass # 如果日期时间格式不正确，则跳过

                adif_record += _format_field("FREQ", rec[3])
                adif_record += _format_field("TX_PWR", rec[4])
                adif_record += _format_field("RST_SENT", rec[8])
                adif_record += _format_field("RST_RCVD", rec[9])
                adif_record += _format_field("QTH", f"{rec[6]} {rec[7]}")
                adif_record += _format_field("STATION_CALLSIGN", rec[10]) # 使用'device'作为自己的呼号
                adif_record += _format_field("COMMENT", rec[11])
                
                f.write(adif_record.strip() + " <EOR>\n")
        return True
    except IOError:
        return False

import re
from modules.helpers import now_str

def _parse_adif_record(record_str):
    """解析单条ADIF记录字符串，返回一个字段字典"""
    record = {}
    # 正则表达式匹配 <TAG:LENGTH>VALUE 或 <TAG:LENGTH:TYPE>VALUE
    pattern = re.compile(r'<(\w+):(\d+)(:[^>]+)?>([^<]+)')
    # ADIF标准不区分大小写，所以我们统一转为大写处理
    matches = pattern.findall(record_str.upper())
    
    for match in matches:
        tag, length, _, value = match
        # 进行基本的长度校验
        if len(value) >= int(length):
            record[tag] = value[:int(length)].strip()
    return record

def import_from_adif(filepath):
    """
    从ADIF文件导入记录。
    返回一个准备插入数据库的QSO元组列表。
    """
    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
    except IOError:
        return []

    # 根据ADIF标准，头信息以 <EOH> 结束
    header_end_match = re.search(r'<EOH>', content, re.IGNORECASE)
    if header_end_match:
        content = content[header_end_match.end():]
    
    # 按 <EOR> (记录结束) 分割记录
    adif_records = re.split(r'<EOR>', content, flags=re.IGNORECASE)
    
    qso_to_add = []

    for rec_str in adif_records:
        if not rec_str.strip():
            continue
        
        adif_data = _parse_adif_record(rec_str)
        
        call = adif_data.get('CALL')
        if not call:
            continue # 呼号是必须的，没有则跳过此条记录

        # 将ADIF字段映射到我们的数据库字段
        mode = adif_data.get('MODE', '')
        freq = adif_data.get('FREQ', '0')
        power = adif_data.get('TX_PWR', '0')
        
        qso_date = adif_data.get('QSO_DATE', '') # 格式: YYYYMMDD
        time_on = adif_data.get('TIME_ON', '')   # 格式: HHMMSS or HHMM
        datetime_str = ""
        if len(qso_date) == 8 and len(time_on) >= 4:
            try:
                # 组合成 YYYY-MM-DD HH:MM 格式
                dt_obj = datetime.datetime.strptime(f"{qso_date}{time_on[:4]}", '%Y%m%d%H%M')
                datetime_str = dt_obj.strftime('%Y-%m-%d %H:%M')
            except ValueError:
                datetime_str = "" # 格式错误则留空

        qth = adif_data.get('QTH', '')
        rst_sent = adif_data.get('RST_SENT', '')
        rst_recv = adif_data.get('RST_RCVD', '')
        content = adif_data.get('COMMENT', '')
        device = adif_data.get('STATION_CALLSIGN', '')

        # 简单的QTH分割，尝试填入省和市
        qth_parts = qth.split()
        qth_prov = qth_parts[0] if qth_parts else ''
        qth_city = ' '.join(qth_parts[1:]) if len(qth_parts) > 1 else ''

        # 准备元组用于批量插入
        qso_to_add.append((
            call, mode, freq, power, datetime_str,
            qth_prov, qth_city, rst_sent, rst_recv,
            content, device, now_str() # 添加 addtime
        ))

    return qso_to_add
